<html>
	<head>
	<link href="basic.css" type="text/css" rel="stylesheet" />
	<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">
	</head>
	<body>
		<div class="container">
			<h1> Normal Select Statement </h1>
			<p> SELECT (Set of Attributes or *) FROM (Database.Table); </p>
			<pre>
				<span>SELECT </span>
				<span>	EmpID,</span>
				<span>	EmpFirstName + ", " + LEFT(EmpLastName,1) + "." AS [FULL NAME],</span>
				<span>	EmpEmail,</span>
				<span>FROM [vle].[tblEmployee];</span>
			</pre>
		</div>

		<div class="container">
			<h1>Group By Select Statement</h1>
			<p>Select (Set of Attributes and/or Aggregate Attributes) FROM (database.table)</p>
			<p>GROUP BY (non-aggregate attributes), (optional aggregate attributes);</p>
			<pre>
				<span>SELECT</span>
				<span>	[ProductTypeID] AS [Product Type ID],</span>
			    <span>	COUNT(*) AS [Count of Products], /* Counts all rows for each product type */</span>
			    <span>	CONVERT(DECIMAL, SUM([QOH])) AS [Total Quanitiy on Hand], /* Gives total quanitiy on hand for each product type */</span>
			    <span>	AVG([QOH]) AS [Average Quanitiy on Hand] /*Gives the average quantity on hand for each product type */</span>
				<span>FROM tblProduct</span>
				<span>GROUP BY [ProductTypeID]</span>
				<span>HAVING AVG([QOH]) > 50; /* Only gives us product types with a greater avg quanitity than 50 */</span>
     		</pre>
     		<h2>Detailed Description</h2>
     		<p>Group by is used for organizing attributes containing aggregate functions. When using a GROUP BY statement there
     		must be at least one aggregate attribute in the SELECT statement and it must be grouped by all non-aggregate attributes. The above
     		select statement shows a basic GROUP BY statement which gives us condensed information about certian product types 
     		in the table tblProduct</p>
     		<h2>List of Aggregate Functions</h2>
     		<pre>
     			<span>MAX() /* Gives the largest value for all values associated with an attribute. Can be used with datetime fields.*/</span>
     			<span>MIN() /* Gives the smallest value for all values associated with an attribute. Can be used with datetime fields.*/</span>
     			<span>SUM() /* Gives the total of all rows of a given attribute added together.*/</span>
     			<span>COUNT() /* Counts the number of rows associated with a given column. Use DISTINCT keyword for unique rows.*/</span>
     			<span>AVG() /* Finds the average of all rows for given attribute */</span>
     		</pre>
		</div>

		<div class="container">
			<h1>Sub-Queries</h1>
			<p>Select (Set of Attributes and/or Aggregate Attributes) FROM (database.table)</p>
			<p>WHERE (Attribute) (= or IN or NOT IN) (SELECT (Attribute(s)) FROM database.table2);</p>
			<pre>
				<span>SELECT</span>
				<span>	ProductID,</span>
				<span>	QtyOrdered,</span>
				<span>	QtyOrdered * Price AS [Total Cost of an OrderLine]</span>
				<span>FROM tblPurchaseOrderLine</span>
				<span>WHERE (QtyOrdered * Price) = (SELECT MAX(QtyOrdered * Price)</span>
				<span>				FROM tblPurchaseOrderLine);</span>
			</pre>
     		<h2>Detailed Description</h2>
     		<p>Sometimes GROUP BY alone fails us when we want just one data point with non-aggregate and aggregate information. In the above example,
     		I want the productID of the order line which cost the most determined as (qtyOrdered * price). This can only be done with a sub-query where
     		we push our aggregate function calls to the sub-query. The best process for building a function of this variety comes from creating the subquery first and determining what
     		WHERE comparaision will give us the data we are looking for.</p>
		</div>

		<div class="container">
			<h1>Views</h1>
			<p>CREATE VIEW (Name of View) AS (Normal Select Statment)</p>
			<pre>
				<span>CREATE VIEW vTblEmployee AS</span>
				<span>Select </span>
				<span>		emp.EmpID,</span>
				<span>		emp.EmpFirstName,</span>
				<span>	 	emp.EmpLastName, </span>
				<span>		mgr.EmpFirstName + ' ' + mgr.EmpLastName AS [Manager Name]</span>
				<span>FROM tblEmployee emp</span>
				<span>LEFT JOIN tblEmployee mgr</span>
				<span>ON	 mgr.EmpID = emp.EmpMgrID;</span>
			</pre>
			<h2>Detailed Description</h2>
			<p>We can think of a view as a variable which holds the table returned from a select query. We can generally use views to
			simplify sub quieries especially when they start to get more complex. Views can also save us some work by giving us a place
			to store result tables we frequently use which are complicated or tedious to type. The above view holds a self join with
			information about employees and thier managers. Self joins can be hard sometimes so we write it once and be done?</p>
		</div>

		<div class="container">
			<h1>Conditional Cases</h1>
			<p> CASE WHEN (conditional statement) THEN (output)</p>
			<pre>
				<span>SELECT	[productId] as [Product Number],</span>
				<span>		[Description] as [Product Description],</span>
				<span>		[EOQ] as [Economic Order Quanity],</span>
				<span>		[QOH] as [Qantity on Hand],</span>
				<span>		[QOH] - [EOQ] as [Difference],</span>
				<span>		CASE</span>
				<span>			WHEN [QOH] = 0</span>
				<span>				THEN 'Order Immediately'</span>
				<span>			WHEN [QOH] - [EOQ] < -35</span>
				<span>				THEN 'Order this week'</span>
				<span>			WHEN [QOH] - [EOQ] < -10</span>
				<span>				THEN 'Order next week'</span>
				<span>			WHEN [QOH] - [EOQ] < -5</span>
				<span>				THEN 'Order next month'</span>
				<span>			WHEN [QOH] - [EOQ] < -1 </span>
				<span>				THEN NULL </span>
				<span>		END		 AS [Order Message]</span>
				<span>FROM tblProduct</span>
				<span>WHERE [QOH] - [EOQ] < 0</span>
				<span>ORDER BY [EOQ] DESC;</span>
			</pre>
			<h2>Detailed Description</h2>
			<p> Case statements are basically if/then statements in other languages. We use them to populate rows with conditional data.
			They are not especially complex, however make sure to arrange your conditions so that values which might be true for two conditions fall into
			the right WHEN statement. For example if we put the bottom condition WHEN [QOH] - [EOQ] < -1 THEN NULL on top, then every situation other than 
			[QOH] - [EOQ] = 0 will output null.</p>
		</div>
	
		<div class="container">
			<h1>Joins</h1>
			<p>Select (Set of Attributes and/or Aggregate Attributes) FROM (database.table)</p>
			<p>(INNER,LEFT OUTER, RIGHT OUTER) JOIN (database.table2)</p>
			<p> ON (database.table.attribute) = (database.table2.attribute);</p>
			<pre>
				<span>SELECT</span>
				<span>	[TPO].[PONumber]		AS [Purchase Order Number],</span>
				<span>	[TPO].[PODatePlaced]	AS [Date Purchase Order Placed],</span>
				<span>	[TPO].[PODateneeded]	AS [Date Needed],</span>
				<span>	[TPO].[Terms],</span>
				<span>	[TPO].[VendorID]		AS [Vendor Number],</span>
				<span>	[tblVendor].[Name]		AS [Vendor Name]</span>
				<span>FROM	tblPurchaseOrder TPO</span>
				<span>INNER JOIN tblVendor</span>
				<span>	ON TPO.VendorID = tblVendor.VendorID</span>
				<span>WHERE TPO.PONumber NOT IN (SELECT PONumber FROM tblReceiver);</span>
			</pre>
     		<h2>Detailed Description</h2>
     		<p>JOINs consist of three total types: LEFT OUTER, RIGHT OUTER, and INNER. LEFT OUTER encompasses the intersect from the JOIN and the rows from the 
			FROM table. RIGHT OUTER emcompasses the intersect as well as the rows from the JOIN'd table. INNER JOIN encompasses the intersect</p>
		</div>	

		<div class="container">
			<h1>Self Joins</h1>
			<p>Select (Set of Attributes and/or Aggregate Attributes) FROM (database.table)</p>
			<p>(INNER,LEFT OUTER, RIGHT OUTER) JOIN (database.table1) AS (ALIAS)</p>
			<p> ON (database.table.attribute) = (ALIAS.attribute);</p>
			<pre>
				<span>SELECT</span>
				<span>	[EMP].[EmpFirstName]		AS [Employee],</span>
				<span>	[Manager].[EmpFirstName]	AS [Manager],</span>
				<span>FROM	tblEmployee EMP</span>
				<span>INNER JOIN tblEmployee Manager</span>
				<span>	ON EMP.ManagerID = Manager.EmpID</span>
			</pre>
     		<h2>Detailed Description</h2>
     		<p>Self JOINs are literally the same as JOINS but you link it to the same table under an ALIAS. Cannot stress that enough, use a goddamn ALIAS.</p>
		</div>

		<div class="container">
			<h1>Join with a Conditional</h1>
			<p>Select (Set of Attributes and/or Aggregate Attributes),</p>
			<p>CASE WHERE (expression) THEN (output) END FROM (database.table)</p>
			<p>(INNER,LEFT OUTER, RIGHT OUTER) JOIN (database.table1) AS (ALIAS)</p>
			<p> ON (database.table.attribute) = (ALIAS.attribute);</p>
			<pre>
				<span>SELECT	POL.PONumber												AS [Purchase Order Number],</span>
				<span>		tblVendor.Name												AS [Vendor Name],</span>
				<span>		tblProduct.ProductID										AS [Product ID],</span>
				<span>		tblProduct.Description										AS [Product Description],</span>
				<span>		CONVERT(VARCHAR, POL.DateNeeded, 107)						AS [Product Date Needed],</span>
				<span>		POL.QtyOrdered												AS [Quantity Ordered],</span>
				<span>		ISNULL(SUM(tblReceiver.QtyReceived), 0.00)					AS [Total Quantity Received],</span>
				<span>		POL.QtyOrdered - ISNULL(SUM(tblReceiver.QtyReceived), 0.00) AS [Quantity Remaining to be Received],</span>
				<span>		CASE</span>
				<span>			WHEN ISNULL(SUM(tblReceiver.QtyReceived), 0.00) = 0</span>
				<span>				THEN 'Not Received'</span>
				<span>			WHEN (POL.QtyOrdered - ISNULL(SUM(tblReceiver.QtyReceived), 0.00)) = 0</span>
				<span>				THEN 'Complete'</span>
				<span>			WHEN (POL.QtyOrdered - ISNULL(SUM(tblReceiver.QtyReceived), 0.00)) < 0</span>
				<span>				THEN 'Over Shipment'</span>
				<span>			WHEN (POL.QtyOrdered - ISNULL(SUM(tblReceiver.QtyReceived), 0.00)) > 0</span>
				<span>				THEN  'Partial Shipment'</span>
				<span>		END															AS  [Receiving Status]</span>
				<span>FROM	tblPurchaseOrder PO</span>
				<span>LEFT JOIN	tblPurchaseOrderLine POL</span>
				<span>ON		PO.PONumber = POL.PONumber</span>
				<span>JOIN	tblProduct</span>
				<span>ON		POL.ProductID = tblProduct.ProductID</span>
				<span>JOIN	tblVendor</span>
				<span>ON		PO.VendorID = tblVendor.VendorID</span>
				<span>LEFT JOIN tblReceiver</span>
				<span>ON		POL.PONumber = tblReceiver.PONumber AND </span>
				<span>		POL.DateNeeded = tblReceiver.DateNeeded AND </span>
				<span>		POL.ProductID = tblReceiver.ProductID</span>
				<span>GROUP BY POL.PONumber, tblVendor.Name, tblProduct.ProductID, tblProduct.Description, POL.DateNeeded, POL.QtyOrdered </span>
				<span>ORDER BY POL.PONumber, tblProduct.ProductID;</span>
			</pre>
     		<h2>Detailed Description</h2>
     		<p>Self JOINs are literally the same as JOINS but you link it to the same table under an ALIAS. Cannot stress that enough, use a goddamn ALIAS.</p>
		</div>

	</body>
</html>